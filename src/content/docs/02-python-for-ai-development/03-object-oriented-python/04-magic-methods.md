---
title: "Magic Methods (Dunder Methods)"
---

# Magic Methods (Dunder Methods)

## Introduction

Magic methods (also called dunder methods for "double underscore") let you define how objects behave with Python's built-in operations. They enable operator overloading, iteration, context management, and more.

### What We'll Cover

- String representation (`__str__`, `__repr__`)
- Comparison operators
- Arithmetic operators
- Container protocols
- Context managers
- Callable objects

### Prerequisites

- Classes and objects
- Operators

---

## String Representation

### `__str__` and `__repr__`

```python
class Point:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y
    
    def __repr__(self) -> str:
        """Unambiguous representation for developers."""
        return f"Point({self.x}, {self.y})"
    
    def __str__(self) -> str:
        """User-friendly string representation."""
        return f"({self.x}, {self.y})"

p = Point(3, 4)

# __repr__ is used for debugging
print(repr(p))  # Point(3, 4)

# __str__ is used for display
print(str(p))   # (3, 4)
print(p)        # (3, 4) - print() uses __str__

# In containers, __repr__ is used
points = [Point(1, 2), Point(3, 4)]
print(points)   # [Point(1, 2), Point(3, 4)]
```

### Best Practices

```python
class User:
    def __init__(self, name: str, email: str):
        self.name = name
        self.email = email
    
    def __repr__(self) -> str:
        # Should ideally be a valid Python expression
        return f"User({self.name!r}, {self.email!r})"
    
    def __str__(self) -> str:
        return f"{self.name} <{self.email}>"

user = User("Alice", "alice@example.com")
print(repr(user))  # User('Alice', 'alice@example.com')
print(str(user))   # Alice <alice@example.com>
```

---

## Comparison Operators

### Basic Comparisons

```python
class Version:
    def __init__(self, major: int, minor: int, patch: int):
        self.major = major
        self.minor = minor
        self.patch = patch
    
    def __eq__(self, other: "Version") -> bool:
        if not isinstance(other, Version):
            return NotImplemented
        return (self.major, self.minor, self.patch) == \
               (other.major, other.minor, other.patch)
    
    def __lt__(self, other: "Version") -> bool:
        if not isinstance(other, Version):
            return NotImplemented
        return (self.major, self.minor, self.patch) < \
               (other.major, other.minor, other.patch)
    
    def __repr__(self) -> str:
        return f"Version({self.major}, {self.minor}, {self.patch})"

v1 = Version(1, 0, 0)
v2 = Version(2, 0, 0)
v3 = Version(1, 0, 0)

print(v1 == v3)  # True
print(v1 < v2)   # True
print(v2 > v1)   # True (Python infers from __lt__)
```

### Using functools.total_ordering

```python
from functools import total_ordering

@total_ordering  # Generates missing comparison methods
class Money:
    def __init__(self, amount: float, currency: str = "USD"):
        self.amount = amount
        self.currency = currency
    
    def __eq__(self, other: "Money") -> bool:
        if not isinstance(other, Money):
            return NotImplemented
        return self.amount == other.amount and self.currency == other.currency
    
    def __lt__(self, other: "Money") -> bool:
        if not isinstance(other, Money):
            return NotImplemented
        if self.currency != other.currency:
            raise ValueError("Cannot compare different currencies")
        return self.amount < other.amount

m1 = Money(100, "USD")
m2 = Money(200, "USD")

print(m1 < m2)   # True
print(m1 <= m2)  # True (generated by @total_ordering)
print(m1 >= m2)  # False
print(m1 > m2)   # False
```

---

## Arithmetic Operators

### Basic Operators

```python
class Vector:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y
    
    def __add__(self, other: "Vector") -> "Vector":
        return Vector(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other: "Vector") -> "Vector":
        return Vector(self.x - other.x, self.y - other.y)
    
    def __mul__(self, scalar: float) -> "Vector":
        return Vector(self.x * scalar, self.y * scalar)
    
    def __rmul__(self, scalar: float) -> "Vector":
        """Right multiplication: scalar * vector"""
        return self * scalar
    
    def __neg__(self) -> "Vector":
        return Vector(-self.x, -self.y)
    
    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

v1 = Vector(1, 2)
v2 = Vector(3, 4)

print(v1 + v2)   # Vector(4, 6)
print(v2 - v1)   # Vector(2, 2)
print(v1 * 3)    # Vector(3, 6)
print(3 * v1)    # Vector(3, 6) - uses __rmul__
print(-v1)       # Vector(-1, -2)
```

### In-Place Operators

```python
class Counter:
    def __init__(self, value: int = 0):
        self.value = value
    
    def __iadd__(self, other: int) -> "Counter":
        """In-place addition: counter += n"""
        self.value += other
        return self
    
    def __repr__(self) -> str:
        return f"Counter({self.value})"

c = Counter(5)
c += 3
print(c)  # Counter(8)
```

---

## Length, Boolean, and Hashing

```python
class Playlist:
    def __init__(self, name: str, songs: list[str] = None):
        self.name = name
        self.songs = songs or []
    
    def __len__(self) -> int:
        """len(playlist)"""
        return len(self.songs)
    
    def __bool__(self) -> bool:
        """bool(playlist) - truthy if has songs"""
        return len(self.songs) > 0
    
    def __hash__(self) -> int:
        """Make hashable (for use in sets/dict keys)"""
        return hash((self.name, tuple(self.songs)))
    
    def __eq__(self, other: "Playlist") -> bool:
        if not isinstance(other, Playlist):
            return NotImplemented
        return self.name == other.name and self.songs == other.songs

p1 = Playlist("Rock", ["Song1", "Song2"])
p2 = Playlist("Empty")

print(len(p1))   # 2
print(bool(p1))  # True
print(bool(p2))  # False

# In conditions
if p1:
    print("Has songs!")

# Hashable - can use as dict key
playlists = {p1: "favorite"}
```

---

## Container Protocol

### Indexing and Iteration

```python
class Matrix:
    def __init__(self, rows: list[list[float]]):
        self._data = rows
    
    def __getitem__(self, key):
        """matrix[i] or matrix[i, j]"""
        if isinstance(key, tuple):
            row, col = key
            return self._data[row][col]
        return self._data[key]
    
    def __setitem__(self, key, value):
        """matrix[i, j] = value"""
        if isinstance(key, tuple):
            row, col = key
            self._data[row][col] = value
        else:
            self._data[key] = value
    
    def __iter__(self):
        """Iterate over rows"""
        return iter(self._data)
    
    def __contains__(self, item) -> bool:
        """item in matrix"""
        return any(item in row for row in self._data)

m = Matrix([[1, 2], [3, 4], [5, 6]])

print(m[0])       # [1, 2]
print(m[1, 1])    # 4
m[0, 1] = 10
print(m[0])       # [1, 10]

for row in m:
    print(row)    # [1, 10], [3, 4], [5, 6]

print(4 in m)     # True
print(7 in m)     # False
```

---

## Context Managers

### `__enter__` and `__exit__`

```python
class Timer:
    """Context manager for timing code blocks."""
    
    def __enter__(self):
        import time
        self.start = time.perf_counter()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end = time.perf_counter()
        self.elapsed = self.end - self.start
        print(f"Elapsed: {self.elapsed:.4f} seconds")
        return False  # Don't suppress exceptions

with Timer() as t:
    # Some code to time
    sum(range(1000000))
# Output: Elapsed: 0.0234 seconds

print(f"Total time: {t.elapsed:.4f}s")
```

### File-Like Context Manager

```python
class ManagedFile:
    def __init__(self, filename: str, mode: str = "r"):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()
        return False

with ManagedFile("test.txt", "w") as f:
    f.write("Hello, World!")
# File automatically closed
```

### Exception Handling in Context Managers

```python
class DatabaseTransaction:
    def __init__(self, connection):
        self.connection = connection
    
    def __enter__(self):
        self.connection.begin()
        return self.connection
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            # No exception - commit
            self.connection.commit()
        else:
            # Exception occurred - rollback
            self.connection.rollback()
        return False  # Re-raise exception if any

# Usage
with DatabaseTransaction(conn) as db:
    db.execute("INSERT INTO users VALUES (...)")
    # If exception, automatically rolls back
```

---

## Callable Objects

### `__call__`

```python
class Multiplier:
    def __init__(self, factor: float):
        self.factor = factor
    
    def __call__(self, value: float) -> float:
        return value * self.factor

double = Multiplier(2)
triple = Multiplier(3)

print(double(5))   # 10
print(triple(5))   # 15

# Works like a function
result = double(triple(4))  # 24
```

### Practical Use: Configurable Functions

```python
class RateLimiter:
    def __init__(self, max_calls: int, period: float):
        self.max_calls = max_calls
        self.period = period
        self.calls = []
    
    def __call__(self, func):
        from functools import wraps
        import time
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time.time()
            # Remove old calls
            self.calls = [t for t in self.calls if now - t < self.period]
            
            if len(self.calls) >= self.max_calls:
                raise Exception("Rate limit exceeded")
            
            self.calls.append(now)
            return func(*args, **kwargs)
        
        return wrapper

@RateLimiter(max_calls=5, period=60)
def api_call():
    print("Making API call...")
```

---

## Other Useful Magic Methods

```python
class CustomClass:
    def __init__(self, value):
        self.value = value
    
    def __del__(self):
        """Destructor - called when object is garbage collected"""
        print(f"Destroying {self.value}")
    
    def __sizeof__(self) -> int:
        """sys.getsizeof(obj)"""
        import sys
        return sys.getsizeof(self.value)
    
    def __format__(self, format_spec: str) -> str:
        """f'{obj:format_spec}'"""
        if format_spec == "upper":
            return str(self.value).upper()
        return str(self.value)

obj = CustomClass("hello")
print(f"{obj:upper}")  # HELLO
```

---

## Hands-on Exercise

### Your Task

Create a `Fraction` class with magic methods:

```python
# Requirements:
# 1. Store numerator and denominator
# 2. __repr__ and __str__
# 3. __add__, __sub__, __mul__, __truediv__
# 4. __eq__ and comparison operators
# 5. Reduce to lowest terms

# Example:
f1 = Fraction(1, 2)
f2 = Fraction(1, 3)
print(f1 + f2)  # 5/6
print(f1 * f2)  # 1/6
print(f1 == Fraction(2, 4))  # True (reduced)
```

<details>
<summary>✅ Solution</summary>

```python
from math import gcd
from functools import total_ordering

@total_ordering
class Fraction:
    def __init__(self, numerator: int, denominator: int):
        if denominator == 0:
            raise ValueError("Denominator cannot be zero")
        
        # Reduce to lowest terms
        common = gcd(numerator, denominator)
        self.num = numerator // common
        self.den = denominator // common
        
        # Ensure denominator is positive
        if self.den < 0:
            self.num = -self.num
            self.den = -self.den
    
    def __repr__(self) -> str:
        return f"Fraction({self.num}, {self.den})"
    
    def __str__(self) -> str:
        if self.den == 1:
            return str(self.num)
        return f"{self.num}/{self.den}"
    
    def __add__(self, other: "Fraction") -> "Fraction":
        return Fraction(
            self.num * other.den + other.num * self.den,
            self.den * other.den
        )
    
    def __sub__(self, other: "Fraction") -> "Fraction":
        return Fraction(
            self.num * other.den - other.num * self.den,
            self.den * other.den
        )
    
    def __mul__(self, other: "Fraction") -> "Fraction":
        return Fraction(self.num * other.num, self.den * other.den)
    
    def __truediv__(self, other: "Fraction") -> "Fraction":
        return Fraction(self.num * other.den, self.den * other.num)
    
    def __eq__(self, other: "Fraction") -> bool:
        return self.num == other.num and self.den == other.den
    
    def __lt__(self, other: "Fraction") -> bool:
        return self.num * other.den < other.num * self.den

# Test
f1 = Fraction(1, 2)
f2 = Fraction(1, 3)
print(f1 + f2)  # 5/6
print(f1 * f2)  # 1/6
print(f1 == Fraction(2, 4))  # True
print(f1 > f2)  # True
```
</details>

---

## Summary

✅ **`__repr__`** for debugging, **`__str__`** for display
✅ **Comparison operators**: `__eq__`, `__lt__`, etc.
✅ **Arithmetic operators**: `__add__`, `__mul__`, etc.
✅ **Container protocol**: `__len__`, `__getitem__`, `__iter__`
✅ **Context managers**: `__enter__`, `__exit__`
✅ **`__call__`** makes objects callable like functions

**Next:** [Decorators](./05-decorators.md)

---

## Further Reading

- [Data Model](https://docs.python.org/3/reference/datamodel.html)
- [Special Method Names](https://docs.python.org/3/reference/datamodel.html#special-method-names)

<!-- 
Sources Consulted:
- Python Docs: https://docs.python.org/3/reference/datamodel.html
-->
