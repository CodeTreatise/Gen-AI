---
title: "Streaming React Components"
---

# Streaming React Components

## Introduction

Streaming React components allows your chat interface to progressively display rich UI as the model generates tool calls. Instead of waiting for the complete response, users see loading states, partial inputs, and finally the rendered component. This creates a responsive, engaging experience.

This lesson covers the AI SDK UI approach using `useChat` with typed tool parts—the production-ready method for generative UI.

### What We'll Cover

- Understanding message parts and tool part types
- Rendering components from tool outputs
- Handling streaming tool inputs
- Multi-tool component rendering
- Step boundaries in multi-step flows

### Prerequisites

- [Generative UI Overview](./00-generative-ui-overview.md)
- [AI SDK Integration (useChat)](../15-ai-sdk-integration-usechat/)
- Understanding of tool calling

---

## Message Parts Architecture

In AI SDK UI, messages contain a `parts` array with different content types:

```typescript
interface UIMessage {
  id: string;
  role: 'user' | 'assistant';
  parts: MessagePart[];
}

type MessagePart =
  | { type: 'text'; text: string }
  | { type: 'tool-${toolName}'; state: ToolState; input?: any; output?: any }
  | { type: 'step-start' }
  | { type: 'dynamic-tool'; toolName: string; ... };
```

### Tool Part Naming Convention

Tool parts use the pattern `tool-${toolName}`:

```tsx
// If your tool is named "displayWeather"
part.type === 'tool-displayWeather'

// If your tool is named "getStockPrice"
part.type === 'tool-getStockPrice'
```

This enables full TypeScript type inference for inputs and outputs.

---

## Basic Component Rendering

### Complete Example

```tsx
'use client';

import { useChat } from '@ai-sdk/react';
import { useState } from 'react';
import { WeatherCard } from '@/components/weather-card';
import { StockCard } from '@/components/stock-card';

export default function Chat() {
  const [input, setInput] = useState('');
  const { messages, sendMessage } = useChat();

  return (
    <div className="chat-container">
      {messages.map((message) => (
        <div key={message.id} className={`message ${message.role}`}>
          <div className="message-role">
            {message.role === 'user' ? 'You' : 'Assistant'}
          </div>
          
          <div className="message-content">
            {message.parts.map((part, index) => (
              <MessagePart key={index} part={part} />
            ))}
          </div>
        </div>
      ))}

      <form onSubmit={(e) => {
        e.preventDefault();
        sendMessage({ text: input });
        setInput('');
      }}>
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Ask anything..."
        />
        <button type="submit">Send</button>
      </form>
    </div>
  );
}

function MessagePart({ part }: { part: any }) {
  switch (part.type) {
    case 'text':
      return <span>{part.text}</span>;

    case 'tool-displayWeather':
      return <WeatherToolPart part={part} />;

    case 'tool-getStockPrice':
      return <StockToolPart part={part} />;

    default:
      return null;
  }
}
```

---

## Tool Part States

Each tool part progresses through states during execution:

```mermaid
stateDiagram-v2
    [*] --> input-streaming
    input-streaming --> input-available: Input complete
    input-available --> output-available: Execute success
    input-available --> output-error: Execute failed
    input-available --> approval-requested: Needs approval
    approval-requested --> output-available: Approved
    approval-requested --> output-error: Denied
    output-available --> [*]
    output-error --> [*]
```

### Handling Each State

```tsx
function WeatherToolPart({ part }: { part: any }) {
  switch (part.state) {
    case 'input-streaming':
      // Tool input is being generated by the model
      return (
        <div className="tool-streaming">
          <Skeleton className="w-48 h-4" />
          <span className="text-muted">Preparing request...</span>
        </div>
      );

    case 'input-available':
      // Input is ready, tool is executing
      return (
        <div className="tool-loading">
          <Spinner />
          <span>Fetching weather for {part.input.location}...</span>
        </div>
      );

    case 'output-available':
      // Tool executed successfully, render component
      return (
        <WeatherCard
          location={part.output.location}
          temperature={part.output.temperature}
          condition={part.output.condition}
        />
      );

    case 'output-error':
      // Tool execution failed
      return (
        <div className="tool-error">
          <AlertCircle className="text-red-500" />
          <span>Failed to fetch weather: {part.errorText}</span>
        </div>
      );

    case 'approval-requested':
      // Tool needs user approval (covered in lesson 04)
      return <ApprovalDialog part={part} />;

    default:
      return null;
  }
}
```

---

## Streaming Tool Inputs

When tool call streaming is enabled (default in AI SDK 5+), you can show partial inputs as they're generated:

### Pre-Rendering Streaming Inputs

```tsx
function StreamingToolPart({ part }: { part: any }) {
  if (part.state === 'input-streaming') {
    // Show partial input as it streams
    return (
      <div className="streaming-preview">
        <code>{JSON.stringify(part.input, null, 2)}</code>
        <span className="cursor-blink">|</span>
      </div>
    );
  }

  // ... handle other states
}
```

### Visual Feedback During Streaming

```tsx
function ToolCallPreview({ part }: { part: any }) {
  const isStreaming = part.state === 'input-streaming';

  return (
    <div className={`tool-preview ${isStreaming ? 'streaming' : ''}`}>
      <div className="tool-header">
        <ToolIcon name={part.toolName} />
        <span className="tool-name">{formatToolName(part.toolName)}</span>
        {isStreaming && <PulsingDot />}
      </div>

      {part.input && (
        <div className="tool-input">
          {Object.entries(part.input).map(([key, value]) => (
            <div key={key} className="input-field">
              <span className="field-name">{key}:</span>
              <span className="field-value">{String(value)}</span>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

```css
.tool-preview {
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  padding: 12px;
  margin: 8px 0;
}

.tool-preview.streaming {
  border-color: #3b82f6;
  animation: pulse-border 1.5s infinite;
}

@keyframes pulse-border {
  0%, 100% { border-color: #3b82f6; }
  50% { border-color: #93c5fd; }
}

.tool-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.tool-name {
  font-weight: 500;
  color: #334155;
}
```

---

## Multiple Tools Pattern

When your chat supports multiple tools, use a component registry pattern:

### Component Registry

```tsx
// components/tool-components.tsx
import { WeatherCard } from './weather-card';
import { StockCard } from './stock-card';
import { FlightCard } from './flight-card';
import { ImageGallery } from './image-gallery';

export const toolComponents: Record<string, React.ComponentType<any>> = {
  displayWeather: WeatherCard,
  getStockPrice: StockCard,
  searchFlights: FlightCard,
  generateImages: ImageGallery,
};

export const toolLoadingMessages: Record<string, (input: any) => string> = {
  displayWeather: (input) => `Checking weather in ${input.location}...`,
  getStockPrice: (input) => `Looking up ${input.symbol}...`,
  searchFlights: (input) => `Searching flights to ${input.destination}...`,
  generateImages: (input) => `Generating images...`,
};
```

### Dynamic Tool Renderer

```tsx
// components/tool-renderer.tsx
import { toolComponents, toolLoadingMessages } from './tool-components';

interface ToolRendererProps {
  toolName: string;
  state: string;
  input?: any;
  output?: any;
  errorText?: string;
}

export function ToolRenderer({ 
  toolName, 
  state, 
  input, 
  output, 
  errorText 
}: ToolRendererProps) {
  const Component = toolComponents[toolName];

  switch (state) {
    case 'input-streaming':
      return <ToolSkeleton toolName={toolName} />;

    case 'input-available':
      const loadingMessage = toolLoadingMessages[toolName]?.(input) 
        || 'Processing...';
      return <ToolLoading message={loadingMessage} />;

    case 'output-available':
      if (!Component) {
        // Fallback for unknown tools
        return <JsonOutput data={output} />;
      }
      return <Component {...output} />;

    case 'output-error':
      return <ToolError toolName={toolName} error={errorText} />;

    default:
      return null;
  }
}
```

### Usage in Chat

```tsx
function MessagePart({ part }: { part: any }) {
  // Handle text
  if (part.type === 'text') {
    return <span>{part.text}</span>;
  }

  // Handle tools dynamically
  if (part.type.startsWith('tool-')) {
    const toolName = part.type.replace('tool-', '');
    return (
      <ToolRenderer
        toolName={toolName}
        state={part.state}
        input={part.input}
        output={part.output}
        errorText={part.errorText}
      />
    );
  }

  // Handle dynamic tools (MCP, runtime-defined)
  if (part.type === 'dynamic-tool') {
    return (
      <ToolRenderer
        toolName={part.toolName}
        state={part.state}
        input={part.input}
        output={part.output}
        errorText={part.errorText}
      />
    );
  }

  return null;
}
```

---

## Step Boundaries

When using multi-step tool calls, step boundaries help visualize the flow:

### Detecting Step Starts

```tsx
function MessageParts({ parts }: { parts: any[] }) {
  return (
    <>
      {parts.map((part, index) => {
        switch (part.type) {
          case 'step-start':
            // Show step boundary (skip for first step)
            return index > 0 ? (
              <div key={index} className="step-boundary">
                <hr />
                <span className="step-label">Step {countSteps(parts, index)}</span>
              </div>
            ) : null;

          case 'text':
            return <span key={index}>{part.text}</span>;

          default:
            if (part.type.startsWith('tool-')) {
              return <ToolRenderer key={index} {...extractToolProps(part)} />;
            }
            return null;
        }
      })}
    </>
  );
}

function countSteps(parts: any[], upToIndex: number): number {
  return parts
    .slice(0, upToIndex + 1)
    .filter(p => p.type === 'step-start')
    .length;
}
```

### Step Boundary Styling

```css
.step-boundary {
  display: flex;
  align-items: center;
  gap: 12px;
  margin: 16px 0;
}

.step-boundary hr {
  flex: 1;
  border: none;
  border-top: 1px dashed #e2e8f0;
}

.step-label {
  font-size: 0.75rem;
  color: #94a3b8;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
```

---

## Animating Component Entry

Add smooth animations when components appear:

```tsx
import { motion, AnimatePresence } from 'framer-motion';

function AnimatedToolPart({ part }: { part: any }) {
  return (
    <AnimatePresence mode="wait">
      {part.state === 'output-available' ? (
        <motion.div
          key="output"
          initial={{ opacity: 0, y: 10, scale: 0.95 }}
          animate={{ opacity: 1, y: 0, scale: 1 }}
          transition={{ duration: 0.3, ease: 'easeOut' }}
        >
          <ToolRenderer {...extractToolProps(part)} />
        </motion.div>
      ) : (
        <motion.div
          key="loading"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <ToolLoading />
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

### CSS-Only Animation Alternative

```css
.tool-component {
  animation: tool-appear 0.3s ease-out;
}

@keyframes tool-appear {
  from {
    opacity: 0;
    transform: translateY(8px) scale(0.98);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

.tool-loading {
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}
```

---

## Best Practices

### Component Design

| Practice | Description |
|----------|-------------|
| Self-contained | Components should include all needed styling |
| Consistent sizing | Define max-width to prevent layout shifts |
| Loading states | Always handle input-available with visual feedback |
| Error handling | Show actionable error messages |
| Accessibility | Include ARIA labels and keyboard support |

### Performance

```tsx
// Memoize heavy components
const MemoizedChart = React.memo(ChartComponent);

// Use in tool renderer
if (part.type === 'tool-showChart') {
  return <MemoizedChart data={part.output.data} />;
}
```

### Type Safety

```typescript
// Define tool output types
interface WeatherOutput {
  location: string;
  temperature: number;
  condition: 'sunny' | 'cloudy' | 'rainy' | 'snowy';
  forecast: { hour: string; temp: number }[];
}

// Type the component props
function WeatherCard({ location, temperature, condition, forecast }: WeatherOutput) {
  // ...
}
```

---

## Summary

✅ Message parts contain text and typed tool parts (`tool-${toolName}`)

✅ Tool parts progress through states: streaming → available → output/error

✅ Use a component registry for multiple tools

✅ Handle streaming inputs for immediate visual feedback

✅ Step boundaries help visualize multi-step tool flows

✅ Animate component entry for polished UX

**Next:** [Artifact Display Patterns](./02-artifact-display-patterns.md)

---

## Further Reading

- [AI SDK Chatbot Tool Usage](https://ai-sdk.dev/docs/ai-sdk-ui/chatbot-tool-usage) — Complete tool parts API
- [AI SDK Generative UI](https://ai-sdk.dev/docs/ai-sdk-ui/generative-user-interfaces) — Official guide
- [Tool Call Streaming](https://ai-sdk.dev/docs/ai-sdk-ui/chatbot-tool-usage#tool-call-streaming) — Streaming inputs

---

<!-- 
Sources Consulted:
- AI SDK Chatbot Tool Usage: https://ai-sdk.dev/docs/ai-sdk-ui/chatbot-tool-usage
- AI SDK Generative UI: https://ai-sdk.dev/docs/ai-sdk-ui/generative-user-interfaces
-->
